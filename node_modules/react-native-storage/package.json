{
  "_args": [
    [
      {
        "raw": "react-native-storage@^0.2.2",
        "scope": null,
        "escapedName": "react-native-storage",
        "name": "react-native-storage",
        "rawSpec": "^0.2.2",
        "spec": ">=0.2.2 <0.3.0",
        "type": "range"
      },
      "/Users/Rahul/Desktop/be_social_app/new_social_app/be_social_app_v2"
    ]
  ],
  "_from": "react-native-storage@^0.2.2",
  "_hasShrinkwrap": false,
  "_id": "react-native-storage@0.2.4",
  "_location": "/react-native-storage",
  "_nodeVersion": "8.12.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-native-storage_0.2.4_1543915190963_0.3293688374563779"
  },
  "_npmUser": {
    "name": "sunnylqm",
    "email": "sunnylqm@qq.com"
  },
  "_npmVersion": "6.4.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-native-storage@^0.2.2",
    "scope": null,
    "escapedName": "react-native-storage",
    "name": "react-native-storage",
    "rawSpec": "^0.2.2",
    "spec": ">=0.2.2 <0.3.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-native-storage/-/react-native-storage-0.2.4.tgz",
  "_shasum": "a3cba3bf28cb0a16d8f9e6ced8aea26b3020ca10",
  "_shrinkwrap": null,
  "_spec": "react-native-storage@^0.2.2",
  "_where": "/Users/Rahul/Desktop/be_social_app/new_social_app/be_social_app_v2",
  "author": {
    "name": "sunnylqm"
  },
  "bugs": {
    "url": "https://github.com/sunnylqm/react-native-storage/issues"
  },
  "dependencies": {},
  "description": "A local storage wrapper for both react-native(AsyncStorage) and browser(localStorage). Support size controlling, auto expiring, remote data auto syncing and getting batch data in one query.",
  "devDependencies": {
    "babel-jest": "^19.0.0",
    "babel-plugin-transform-object-rest-spread": "^6.23.0",
    "babel-preset-es2015": "^6.24.1",
    "jest": "^19.0.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-A+szWzEjZx05gSieuV20aR/v0iCuQpsFBzABLhJMtVFecUMzGVbuRMBX2PngSXT+94X/7PRi80BSnoLBgNYZtw==",
    "shasum": "a3cba3bf28cb0a16d8f9e6ced8aea26b3020ca10",
    "tarball": "https://registry.npmjs.org/react-native-storage/-/react-native-storage-0.2.4.tgz",
    "fileCount": 9,
    "unpackedSize": 119912,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcBka3CRA9TVsSAnZWagAAnIcQAJZsKITiaX+lczPuE2fP\n2eGBkS3n7gHgWWday21X07/bwsQn7xiRFstT3zRbHAGl0azAO81VeiTPW9f5\nsWoLEOOeCWVm/ms3oIaPSusnBrd6vmxEOtA0MXM3vK/1oO9egJ5tQFnpufOl\ne5XPyBCmpl0m2JAaYbtCziwdqpxbaq0rA/4WETJXKWywwIhKR6T+aTt4k4Zc\n2RvzJIGtcI7pyYvwkpDAkxZv17WfqVO1bQMca68tcQN7TxksTdAJXPM26uYe\nudM+OfDEe6PMrha1qE0108umKRG038Yk2jVDxa/L030JWncT5W8unInZ3IGe\nJv1eSvXVPwlZWCpdrkDmPbrGfJitkxIEHBykufUv2s2A4AJtxC8wXSB2lDbg\ndRHhe1B6nrdQlUdoQm+IhI86OQMYDeWWNraVxB2r8d0IwaiUP6gSy9Q8ha7M\njJBehRFqbEtw3KK077NgTeLXsi9rBjD2OIGHGuZRokSYfUROfBTtfIlCg6Hg\ng987dwGwhgTVbjT03WLEAyFXDNFAHxiyymtiIrX8qRSWX8VMCbk6+0w26kei\nLoU7zgw/beKTXd8RqPvS0bQqn5kN/umkvd9LTme/VK5ERleECC/sd6vRgXnx\njEeMk2vkY/9VHOcMesjuN6wJoUNCaBmeZvD8cSDQEw7C9cUkmvdiv0ATHl5N\nfT2f\r\n=juST\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "316cd6a9b9179d863343c93d2e0e786c639defb1",
  "homepage": "https://github.com/sunnylqm/react-native-storage#readme",
  "jest": {
    "verbose": true,
    "bail": true,
    "setupFiles": [
      "./jestSupport/mockStorage.js"
    ]
  },
  "keywords": [
    "react-native",
    "localStorage",
    "AsyncStorage"
  ],
  "license": "MIT",
  "main": "storage.js",
  "maintainers": [
    {
      "name": "sunnylqm",
      "email": "sunnylqm@qq.com"
    }
  ],
  "name": "react-native-storage",
  "optionalDependencies": {},
  "readme": "# react-native-storage [![Build Status](https://travis-ci.org/sunnylqm/react-native-storage.svg)](https://travis-ci.org/sunnylqm/react-native-storage)  [![npm version](https://badge.fury.io/js/react-native-storage.svg)](http://badge.fury.io/js/react-native-storage)\n\nThis is a local storage wrapper for both mobile React-Native apps (using AsyncStorage) and React browser-invoked web apps (using localStorage). [ES6](http://babeljs.io/docs/learn-es2015/) syntax, promise for async load, fully tested with jest.\n\n查看中文文档[请点击README-CHN.md](README-CHN.md)\n\n## Install\n\n\tnpm install react-native-storage --save\n\n## Usage\n\n### Config\n#### For Web\nYou need to use [webpack](http://webpack.github.io/) and [babel](https://babeljs.io/) to enable es6 modules for web development.   \nAdd the following lines to your webpack config:  \n\n```javascript\n  // ...\n  module: {\n    loaders: [\n      // ...\n        {\n          test: /\\.js?$/,\n          include: [\n            // path.join(__dirname, 'your-own-js-files'),\n            // path.join(__dirname, 'node_modules/some-other-lib-that-needs-babel'),\n            path.join(__dirname, 'node_modules/react-native-storage')\n          ],\n          loader: 'babel',\n          query: {\n            cacheDirectory: true,\n            presets: ['es2015', 'stage-1', 'react'],\n            plugins: ['transform-runtime']\n          }\n        }\n    ]\n  }\n\n```  \n\n#### For React Native\nYou don't have to configure anything (but React Native version >= 0.13 is required).\n \n\n### Import\n\n```bash\nimport Storage from 'react-native-storage';\n```  \n\nDo not use `require('react-native-storage')`, which will cause an error in react native version >= 0.16.\n\n### Init\n\n```js\nimport Storage from 'react-native-storage';\nimport { AsyncStorage } from 'react-native';\n\nvar storage = new Storage({\n\t// maximum capacity, default 1000 \n\tsize: 1000,\n\n\t// Use AsyncStorage for RN apps, or window.localStorage for web apps.\n\t// If storageBackend is not set, data will be lost after reload.\n\tstorageBackend: AsyncStorage, // for web: window.localStorage\n\t\n\t// expire time, default: 1 day (1000 * 3600 * 24 milliseconds).\n\t// can be null, which means never expire.\n\tdefaultExpires: 1000 * 3600 * 24,\n\t\n\t// cache data in the memory. default is true.\n\tenableCache: true,\n\t\n\t// if data was not found in storage or expired data was found,\n\t// the corresponding sync method will be invoked returning \n\t// the latest data.\n\tsync : {\n\t\t// we'll talk about the details later.\n\t}\n})\t\n\n// I suggest you have one (and only one) storage instance in global scope.\n\n// for web\n// window.storage = storage;\n\n// for react native\n// global.storage = storage;\n```\n\n### Save & Load & Remove\n\n```js\n// Save something with key only. (using only a keyname but no id)\n// This key should be unique. This is for data frequently used.\n// The key and value pair is permanently stored unless you remove it yourself.\nstorage.save({\n\tkey: 'loginState',   // Note: Do not use underscore(\"_\") in key!\n\tdata: { \n\t\tfrom: 'some other site',\n\t\tuserid: 'some userid',\n\t\ttoken: 'some token'\n\t},\n\t\n\t// if expires not specified, the defaultExpires will be applied instead.\n\t// if set to null, then it will never expire.\n\texpires: 1000 * 3600\n});\n\n// load\nstorage.load({\n\tkey: 'loginState',\n\t\n\t// autoSync (default: true) means if data is not found or has expired,\n\t// then invoke the corresponding sync method\n\tautoSync: true,\n\t\n\t// syncInBackground (default: true) means if data expired,\n\t// return the outdated data first while invoking the sync method.\n\t// If syncInBackground is set to false, and there is expired data, \n\t// it will wait for the new data and return only after the sync completed. \n\t// (This, of course, is slower)\n\tsyncInBackground: true,\n\t\n\t// you can pass extra params to the sync method\n\t// see sync example below\n\tsyncParams: {\n\t  extraFetchOptions: {\n\t    // blahblah\n\t  },\n\t  someFlag: true,\n\t},\n}).then(ret => {\n\t// found data go to then()\n\tconsole.log(ret.userid);\n}).catch(err => {\n\t// any exception including data not found \n\t// goes to catch()\n\tconsole.warn(err.message);\n\tswitch (err.name) {\n\t    case 'NotFoundError':\n\t        // TODO;\n\t        break;\n        case 'ExpiredError':\n            // TODO\n            break;\n\t}\n})\n\n// --------------------------------------------------\n\n// Save something with key and id. \n// \"key-id\" data size cannot surpass the size parameter you pass in the constructor.\n// By default the 1001st data will overwrite the 1st data item. \n// If you then load the 1st data, a catch(NotFoundError) or sync will be invoked.\nvar userA = {\n\tname: 'A',\n\tage: 20,\n\ttags: [\n\t\t'geek',\n\t\t'nerd',\n\t\t'otaku'\n\t]\n};\n\nstorage.save({\n\tkey: 'user',  // Note: Do not use underscore(\"_\") in key!\n\tid: '1001',   // Note: Do not use underscore(\"_\") in id!\t\n\tdata: userA,\n\texpires: 1000 * 60\t \n});\n\n// load\nstorage.load({\n\tkey: 'user',\n\tid: '1001'\n}).then(ret => {\n\t// found data goes to then()\n\tconsole.log(ret.userid);\n}).catch(err => {\n\t// any exception including data not found \n\t// goes to catch()\n\tconsole.warn(err.message);\n\tswitch (err.name) {\n\t    case 'NotFoundError':\n\t        // TODO;\n\t        break;\n        case 'ExpiredError':\n            // TODO\n            break;\n\t}\n});\n\n// --------------------------------------------------\n\n// get all ids for \"key-id\" data under a key, \n// note: does not include \"key-only\" information (which has no ids) \nstorage.getIdsForKey('user').then(ids => {\n    console.log(ids);\n});\n\n// get all the \"key-id\" data under a key\n// !! important: this does not include \"key-only\" data\nstorage.getAllDataForKey('user').then(users => {\n    console.log(users);\n});\n\n// clear all \"key-id\" data under a key \n// !! important: \"key-only\" data is not cleared by this function\nstorage.clearMapForKey('user');\n\n\n// --------------------------------------------------  \n\n// remove a single record\nstorage.remove({\n\tkey: 'lastPage'\n});\nstorage.remove({\n\tkey: 'user',\n\tid: '1001'\n});\n\n// clear map and remove all \"key-id\" data \n// !! important: \"key-only\" data is not cleared, and is left intact\nstorage.clearMap();\n```\n\n### Sync remote data(refresh)\nThere are two ways to set the sync method. \nYou can pass the sync method in the constructor's parameter, as a function in an object, \nor you can define it at any time as shown below: \n\n```js\nstorage.sync = {\n\n\t// The name of the sync method must be the same as the data's key name\n\t// And the passed params will be an all-in-one object.\n\t// You can either use promise here, or a plain callback function with resolve/reject, like:\n\tuser(params){\n\t\tlet { id, resolve, reject, syncParams: { extraFetchOptions, someFlag } } = params;\n\t\tfetch('user/', {\n\t\t\tmethod: 'GET',\n\t\t\tbody: 'id=' + id,\n\t\t    ...extraFetchOptions,\n\t\t}).then(response => {\n\t\t\treturn response.json();\n\t\t}).then(json => {\n\t\t\t// console.log(json);\n\t\t\tif(json && json.user){\n\t\t\t\tstorage.save({\n\t\t\t\t\tkey: 'user',\n\t\t\t\t\tid,\n\t\t\t\t\tdata: json.user\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (someFlag) {\n\t\t\t\t  // do something for this extra param\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Call resolve() when succeed\n\t\t\t\tresolve && resolve(json.user);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// Call reject() when failed\n\t\t\t\treject && reject(new Error('data parse error'));\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.warn(err);\n\t\t\treject && reject(err);\n\t\t});\n\t}\n}\n```\n\nIn the following example the sync method is called, when you invoke `storage.load`:    \n\n```js\nstorage.load({\n\tkey: 'user',\n\tid: '1002'\n}).then(...)\n```\n\nIf there is no user 1002 currently in storage, then storage.sync.user will be invoked to fetch and return the remote data.    \n\n### Load batch data\n\n```js\n// Load batch data with an array of `storage.load` parameters.\n// It will invoke each key's sync method, \n// and when all are complete will return all the data in an ordered array.\n// The sync methods behave according to the syncInBackground setting: (default true)\n// When set to true (the default), if timed out will return the current value \n// while when set to false, will wait till the sync method completes\n\nstorage.getBatchData([\n\t{ key: 'loginState' },\n\t{ key: 'checkPoint', syncInBackground: false },\n\t{ key: 'balance' },\n\t{ key: 'user', id: '1009' }\n])\n.then(results => {\n\tresults.forEach(result => {\n\t\tconsole.log(result); \n\t})\n})\n\n// Load batch data with one key and an array of ids.\nstorage.getBatchDataWithIds({\n\tkey: 'user', \n\tids: ['1001', '1002', '1003']\n})\n.then( ... )\n```\n\nThere is an important  difference between the way these two methods perform:\n**getBatchData** will invoke separate sync methods for each different key one after the other when the corresponding data is missing or not in sync. However, **getBatchDataWithIds** will collect a list of the missing data, pushing their ids to an array, and then pass the array to the single corresponding sync method once, reducing the number of requests, so you need to implement array query on the server side and handle the parameters of sync method properly. Note that the id parameter can be a single string or an array of strings.\n\n\n#### You are welcome to ask any question in the [issues](https://github.com/sunnylqm/react-native-storage/issues) page.\n\n### Changelog\n\n#### 0.2.2\n1. check key availability in clearMapForKey\n\n#### 0.2.0\n1. `rawData` is now deprecated, use \"data\" instead!\n2. Upgrade jest to 19.0.0\n\n#### 0.1.5\n1. Now you can pass extra params to sync method.\n2. Fix clearMap\n\n#### 0.1.4\n1. Now you can check error type (NotFoundError and ExpiredError) in catch\n2. Optimize cache strategy\n\n#### 0.1.3\n1. Now you need to specify storageBackend(AsyncStorage or window.localStorage), otherwise the data would not be persisted.\n\n#### 0.1.2\n1. Now when load() failed to find data, it will throw an Error with message instead of undefined.\n\n#### 0.1.1\n1. `defaultExpires` can be `null` now, which means never expire.\n\n#### 0.1.0\n1. add getIdsForKey, getAllDataForKey, clearMapForKey methods\n2. fix some expires logic\n3. refactor unit tests\n\n#### 0.0.16\n1. getBatchDataWithIds now won't invoke sync if everything is ready in storage.\n\n#### 0.0.15\n1. Fix bugs in promise chain.\n2. Can be used without any storage backend.(Use in-memory map)\n\n#### 0.0.10  \n1. All methods except remove and clearMap are now totally promisified. Even custom sync methods can be promise. So you can chain them now. \n2. Adjust map structure.\n3. Improved some test cases.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sunnylqm/react-native-storage.git"
  },
  "scripts": {
    "test": "jest"
  },
  "version": "0.2.4"
}
